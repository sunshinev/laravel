#larvel自动加载
## 代码流程
> 最核心的就是通过psr0和psr4的规则，来查找文件，并且注册loadClass方法到自动加载队列。


在`public/index.php` 中有如下代码

	/*
	|--------------------------------------------------------------------------
	| Register The Auto Loader
	|--------------------------------------------------------------------------
	|
	| Composer provides a convenient, automatically generated class loader for
	| our application. We just need to utilize it! We'll simply require it
	| into the script here so that we don't have to worry about manual
	| loading any of our classes later on. It feels nice to relax.
	|
	composer 提供了方便、自动生成的加载类，不用担心手动加载任何类。
	*/
	require __DIR__.'/../bootstrap/autoload.php';

我们来看下这个autoload.php文件，这个文件中，又require了另外一个autoload.php

	/*
	|--------------------------------------------------------------------------
	| Register The Composer Auto Loader
	|--------------------------------------------------------------------------
	|
	| Composer provides a convenient, automatically generated class loader
	| for our application. We just need to utilize it! We'll require it
	| into the script here so that we do not have to worry about the
	| loading of any our classes "manually". Feels great to relax.
	|
	这里还是说composer提供了一个加载类，我们只需要utilize它就好了
	*/
	
	require __DIR__.'/../vendor/autoload.php';

然后我们继续来看这个autoload.php做了什么

	<?php
	
	// autoload.php @generated by Composer
	
	require_once __DIR__ . '/composer' . '/autoload_real.php';
	
	return ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee::getLoader();

上面的代码，直接require了composer的autoload\_real.php 并且静态调用了get::Loader()方法。我们来看autoload_real.php文件中的getLoader方法，做了什么。

	class ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee
	{
	    private static $loader;
	
	    public static function loadClassLoader($class)
	    {
	        if ('Composer\Autoload\ClassLoader' === $class) {
	            require __DIR__ . '/ClassLoader.php';
	        }
	    }
		// 这里用了单例模式，如果self::$loader已经存在，那么直接返回
	    public static function getLoader()
	    {
	        if (null !== self::$loader) {
	            return self::$loader;
	        }
			// 注册了当前类下面的loadClassLoader方法，并且允许报错，第三个参数是将这个注册过程放到队列的最前面来优先执行。
	        spl_autoload_register(array('ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee', 'loadClassLoader'), true, true);
			// 注册成功之后，直接进行实例化，并且通过自动加载，来加载了ClassLoader类
	        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
			// 实例化和赋值后，注销自动加载器
	        spl_autoload_unregister(array('ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee', 'loadClassLoader'));

			// 开始加载命名空间映射
	        $map = require __DIR__ . '/autoload_namespaces.php';
	        foreach ($map as $namespace => $path) {
	            //通过set方法生成了$loader->prefixesPsr0
	            $loader->set($namespace, $path);
	        }
			// 加载psr4的命名空间映射$this->
	        $map = require __DIR__ . '/autoload_psr4.php';
	        foreach ($map as $namespace => $path) {
	            //通过setPsr4方法生成了$loader->prefixDirsPsr4
	            $loader->setPsr4($namespace, $path);
	        }
			// 加载了一个类地图生成一个$this->classmap
	        $classMap = require __DIR__ . '/autoload_classmap.php';
	        if ($classMap) {
	            $loader->addClassMap($classMap);
	        }
	
			// 执行注册方法，这个地方就是将ClassLoader下面的loadClass方法注册到自动加载
	        $loader->register(true);
	
	        $includeFiles = require __DIR__ . '/autoload_files.php';
	        foreach ($includeFiles as $fileIdentifier => $file) {
	            composerRequire97b17a1a5f1ddaa3bd59bde2233bd0ee($fileIdentifier, $file);
	        }
	
	        return $loader;
	    }
	}


上面的代码中，都做了注释可以看下注释内容，主要完成的就是将预先定义好的映射关系加载到指定的对象里面，然后注册了loadClass方法到自动加载器中。那我们在来看下`\vendor\composer\ClassLoader.php`中的loadClass做了什么。

	/**
	* Loads the given class or interface.
	* 加载给出的类或者接口
	* @param  string    $class The name of the class
	* @return bool|null True if loaded, null otherwise
	*/
	public function loadClass($class)
	{
	    if ($file = $this->findFile($class)) {
	        includeFile($file);
	        return true;
	    }
	}

看来loadClass主要还是使用了findFile，继续看findFile方法。

	/**
	* Finds the path to the file where the class is defined.
	* 找到定义这个类的文件的路径，就是找到这个类是在哪儿进行定义的
	* @param string $class The name of the class
	*
	* @return string|false The path if found, false otherwise
	*/
	
	public function findFile($class)
	{
	
	// work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731
	// 删除类名称前面的\反斜线
	if ('\\' == $class[0]) {
	    $class = substr($class, 1);
	}
	
	// class map lookup
	// 如果这个类已经在之前的classMap中加载了，也就是laravel已经预先定义了，那么直接返回路径
	if (isset($this->classMap[$class])) {
	    return $this->classMap[$class];
	}
	if ($this->classMapAuthoritative) {
	    return false;
	}
	
	// 通过添加后缀名称来寻找文件
	$file = $this->findFileWithExtension($class, '.php');
	
	// Search for Hack files if we are running on HHVM
	if ($file === null && defined('HHVM_VERSION')) {
	    $file = $this->findFileWithExtension($class, '.hh');
	}
	
	if ($file === null) {
	    // Remember that this class does not exist.
	    return $this->classMap[$class] = false;
	}
	
	return $file;
	}

findFile方法中包含了一个findFileWithExtension方法，来看看他做了什么。
	
	// 这个方法接收一个class名称，还有一个ext后缀
	private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup  按照psr-4规则来进行查找，将类的名称通过路径分隔符来进行替换，strtr用来替换字符，不是字符串，所以速度要快。
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;
		// 这里就得到了路径了，然后获取整个路径的第一个字母
        $first = $class[0];
		// 判断之间的加载中，是否有这个psr4的length，这样通过第一个字母来分类，应该也是为了加快搜索速度
        if (isset($this->prefixLengthsPsr4[$first])) {
			// 遍历这个字母分支下的叶子，拿到prefix前缀
            foreach ($this->prefixLengthsPsr4[$first] as $prefix => $length) {
				// 如果类名字中不包含前缀，那么遍历对应的前缀数组，得到路径，如果路径存在，返回文件。
                if (0 === strpos($class, $prefix)) {
                    foreach ($this->prefixDirsPsr4[$prefix] as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup   这里的区别其实是psr-0和psr-4的区别，psr-0中下划线要作为目录分割符处理
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }
    }
通过上面我们可以找到，实际上findFileWithExtension就是按照psr0和psr4的规则来寻找类文件。
我们再重新看之前的loadClass方法，已经被注册到了自动加载的队列中，所以loadClass就是根据class的名称，经过psr0和psr4的规则的处理，得到路径，然后include这个查找到的文件。