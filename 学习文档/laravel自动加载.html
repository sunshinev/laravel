<!DOCTYPE html>
<html>
<head>
<title>laravel自动加载</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>larvel自动加载</h1>
<h2>代码流程</h2>
<blockquote>
<p>最核心的就是通过psr0和psr4的规则，来查找文件，并且注册loadClass方法到自动加载队列。</p>
</blockquote>
<p>在<code>public/index.php</code> 中有如下代码</p>
<pre><code>/*
|--------------------------------------------------------------------------
| Register The Auto Loader
|--------------------------------------------------------------------------
|
| Composer provides a convenient, automatically generated class loader for
| our application. We just need to utilize it! We'll simply require it
| into the script here so that we don't have to worry about manual
| loading any of our classes later on. It feels nice to relax.
|
composer 提供了方便、自动生成的加载类，不用担心手动加载任何类。
*/
require __DIR__.'/../bootstrap/autoload.php';
</code></pre>

<p>我们来看下这个autoload.php文件，这个文件中，又require了另外一个autoload.php</p>
<pre><code>/*
|--------------------------------------------------------------------------
| Register The Composer Auto Loader
|--------------------------------------------------------------------------
|
| Composer provides a convenient, automatically generated class loader
| for our application. We just need to utilize it! We'll require it
| into the script here so that we do not have to worry about the
| loading of any our classes &quot;manually&quot;. Feels great to relax.
|
这里还是说composer提供了一个加载类，我们只需要utilize它就好了
*/

require __DIR__.'/../vendor/autoload.php';
</code></pre>

<p>然后我们继续来看这个autoload.php做了什么</p>
<pre><code>&lt;?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer' . '/autoload_real.php';

return ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee::getLoader();
</code></pre>

<p>上面的代码，直接require了composer的autoload_real.php 并且静态调用了get::Loader()方法。我们来看autoload_real.php文件中的getLoader方法，做了什么。</p>
<pre><code>class ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }
    // 这里用了单例模式，如果self::$loader已经存在，那么直接返回
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }
        // 注册了当前类下面的loadClassLoader方法，并且允许报错，第三个参数是将这个注册过程放到队列的最前面来优先执行。
        spl_autoload_register(array('ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee', 'loadClassLoader'), true, true);
        // 注册成功之后，直接进行实例化，并且通过自动加载，来加载了ClassLoader类
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        // 实例化和赋值后，注销自动加载器
        spl_autoload_unregister(array('ComposerAutoloaderInit97b17a1a5f1ddaa3bd59bde2233bd0ee', 'loadClassLoader'));

        // 开始加载命名空间映射
        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace =&gt; $path) {
            //通过set方法生成了$loader-&gt;prefixesPsr0
            $loader-&gt;set($namespace, $path);
        }
        // 加载psr4的命名空间映射$this-&gt;
        $map = require __DIR__ . '/autoload_psr4.php';
        foreach ($map as $namespace =&gt; $path) {
            //通过setPsr4方法生成了$loader-&gt;prefixDirsPsr4
            $loader-&gt;setPsr4($namespace, $path);
        }
        // 加载了一个类地图生成一个$this-&gt;classmap
        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader-&gt;addClassMap($classMap);
        }

        // 执行注册方法，这个地方就是将ClassLoader下面的loadClass方法注册到自动加载
        $loader-&gt;register(true);

        $includeFiles = require __DIR__ . '/autoload_files.php';
        foreach ($includeFiles as $fileIdentifier =&gt; $file) {
            composerRequire97b17a1a5f1ddaa3bd59bde2233bd0ee($fileIdentifier, $file);
        }

        return $loader;
    }
}
</code></pre>

<p>上面的代码中，都做了注释可以看下注释内容，主要完成的就是将预先定义好的映射关系加载到指定的对象里面，然后注册了loadClass方法到自动加载器中。那我们在来看下<code>\vendor\composer\ClassLoader.php</code>中的loadClass做了什么。</p>
<pre><code>/**
* Loads the given class or interface.
* 加载给出的类或者接口
* @param  string    $class The name of the class
* @return bool|null True if loaded, null otherwise
*/
public function loadClass($class)
{
    if ($file = $this-&gt;findFile($class)) {
        includeFile($file);
        return true;
    }
}
</code></pre>

<p>看来loadClass主要还是使用了findFile，继续看findFile方法。</p>
<pre><code>/**
* Finds the path to the file where the class is defined.
* 找到定义这个类的文件的路径，就是找到这个类是在哪儿进行定义的
* @param string $class The name of the class
*
* @return string|false The path if found, false otherwise
*/

public function findFile($class)
{

// work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731
// 删除类名称前面的\反斜线
if ('\\' == $class[0]) {
    $class = substr($class, 1);
}

// class map lookup
// 如果这个类已经在之前的classMap中加载了，也就是laravel已经预先定义了，那么直接返回路径
if (isset($this-&gt;classMap[$class])) {
    return $this-&gt;classMap[$class];
}
if ($this-&gt;classMapAuthoritative) {
    return false;
}

// 通过添加后缀名称来寻找文件
$file = $this-&gt;findFileWithExtension($class, '.php');

// Search for Hack files if we are running on HHVM
if ($file === null &amp;&amp; defined('HHVM_VERSION')) {
    $file = $this-&gt;findFileWithExtension($class, '.hh');
}

if ($file === null) {
    // Remember that this class does not exist.
    return $this-&gt;classMap[$class] = false;
}

return $file;
}
</code></pre>

<p>findFile方法中包含了一个findFileWithExtension方法，来看看他做了什么。</p>
<pre><code>// 这个方法接收一个class名称，还有一个ext后缀
private function findFileWithExtension($class, $ext)
{
    // PSR-4 lookup  按照psr-4规则来进行查找，将类的名称通过路径分隔符来进行替换，strtr用来替换字符，不是字符串，所以速度要快。
    $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;
    // 这里就得到了路径了，然后获取整个路径的第一个字母
    $first = $class[0];
    // 判断之间的加载中，是否有这个psr4的length，这样通过第一个字母来分类，应该也是为了加快搜索速度
    if (isset($this-&gt;prefixLengthsPsr4[$first])) {
        // 遍历这个字母分支下的叶子，拿到prefix前缀
        foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt; $length) {
            // 如果类名字中不包含前缀，那么遍历对应的前缀数组，得到路径，如果路径存在，返回文件。
            if (0 === strpos($class, $prefix)) {
                foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir) {
                    if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
                        return $file;
                    }
                }
            }
        }
    }

    // PSR-4 fallback dirs
    foreach ($this-&gt;fallbackDirsPsr4 as $dir) {
        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
            return $file;
        }
    }

    // PSR-0 lookup   这里的区别其实是psr-0和psr-4的区别，psr-0中下划线要作为目录分割符处理
    if (false !== $pos = strrpos($class, '\\')) {
        // namespaced class name
        $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
            . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
    } else {
        // PEAR-like class name
        $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
    }

    if (isset($this-&gt;prefixesPsr0[$first])) {
        foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) {
            if (0 === strpos($class, $prefix)) {
                foreach ($dirs as $dir) {
                    if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                        return $file;
                    }
                }
            }
        }
    }

    // PSR-0 fallback dirs
    foreach ($this-&gt;fallbackDirsPsr0 as $dir) {
        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
            return $file;
        }
    }

    // PSR-0 include paths.
    if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) {
        return $file;
    }
}
</code></pre>

<p>通过上面我们可以找到，实际上findFileWithExtension就是按照psr0和psr4的规则来寻找类文件。
我们再重新看之前的loadClass方法，已经被注册到了自动加载的队列中，所以loadClass就是根据class的名称，经过psr0和psr4的规则的处理，得到路径，然后include这个查找到的文件。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
